<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
We can solve this problem in O(n) time using an Efficient Solution.


Мы можем решить эту проблему в O (n) раз, используя эффективное решение.
Идея заключается в использовании Хейшинга.
Сначала мы вставляем все элементы в хэш.
Затем проверьте все возможные последовательности последовательных подпоследовательностей.
Ниже приведен полный алгоритм.
1) Создайте пустой хэш.
2) Вставьте все элементы массива в хэш.
3) Следуйте для каждого элемента arr [i]
.... a) Проверьте, является ли этот элемент отправной точкой
       подпоследовательности. Чтобы проверить это, мы просто ищем
       arr [i] - 1 в hash, если не найден, то это
       первый элемент - подпоследовательность.
    
       Если этот элемент является первым элементом, то подсчет
       количество элементов в последовательном запуске
       с этим элементом.

       Если счетчик больше текущих, то обновите
       Рез.



</body>

<script>
    let arr1 = [100, 4, 200, 1, 3, 2, 101, 102, 103, 104];



    function longestConsecutiveLength(array) {
//        решение с сортировкой
//        if (array.length === 0) {
//            return 0;
//        }
//
//        array.sort(function (a, b) {
//            return a - b;
//        });
//
//        let counter = 1;
//        let maxCounter = 1;
//        let consecutive = true;
//        for (let i = 0 ; i < array.length -1; i++) {
//            if (array[i] + 1 === array[i + 1]) {
//                consecutive = true;
//                counter++;
//            } else if (array[i] === array[i + 1]) {
//                continue;
//            } else {
//                consecutive = false;
//                if (counter > maxCounter) {
//                    maxCounter = counter;
//                }
//                counter = 1;
//            }
//        }
//        return maxCounter;

//        решение из интернет неверное


//        if (array.length === 0) {
//            return 0;
//        }
//
//        let set = [];
//        let maxCounter = 1;
//
//        for (let i = 0; i < array.length; i++) {
//            set.push(array[i]);
//        }
//
//        for (let i = 0; i < array.length; i++) {
//            let left = array[i] - 1;
//            let right = array[i] + 1;
//            let count = 1;
//
//            while (set.indexOf(left) !== -1) {
//                count++;
//                set.splice(set.indexOf(left), 1);
//                left--;
//            }
//
//            while (set.indexOf(right) !== -1) {
//                count++;
//                set.splice(set.indexOf(right), 1);
//                right++;
//            }
//
//            maxCounter = Math.max(count, maxCounter);
//        }
//
//        return maxCounter;

        if (array.length === 0) {
            return 0;
        }

        let obj = {};

        for (let i = 0; i < array.length; i++) {
            obj[array[i]] = 1;
        }


        let maxCounter = 1;

        for (let j = 0; j < array.length; j++) {
            if (!obj[array[j] - 1]) {
                let k = array[j];

                while (obj[k]) {
                    k++;
                    if (maxCounter < k - array[j]) {
                        maxCounter = k - array[j];
                    }
                }

            }

        }

        return maxCounter;
    }



</script>
</html>