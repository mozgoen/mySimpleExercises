<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
We can solve this problem in O(n) time using an Efficient Solution.


Мы можем решить эту проблему в O (n) раз, используя эффективное решение.
Идея заключается в использовании Хейшинга.
Сначала мы вставляем все элементы в хэш.
Затем проверьте все возможные последовательности последовательных подпоследовательностей.
Ниже приведен полный алгоритм.
1) Создайте пустой хэш.
2) Вставьте все элементы массива в хэш.
3) Следуйте для каждого элемента arr [i]
.... a) Проверьте, является ли этот элемент отправной точкой
       подпоследовательности. Чтобы проверить это, мы просто ищем
       arr [i] - 1 в hash, если не найден, то это
       первый элемент - подпоследовательность.
    
       Если этот элемент является первым элементом, то подсчет
       количество элементов в последовательном запуске
       с этим элементом.

       Если счетчик больше текущих, то обновите
       Рез.



</body>

<script>
    let arr1 = [100, 4, 200, 1, 3, 2, 101, 102, 103, 104];



    function longestConsecutiveLength(array) {

        if (array.length === 0) {
            return 0;
        }

        let obj = {};

        for (let i = 0, len = array.length; i < len; i++) {
            obj[array[i]] = array[i];
        }

        let counter = 1;
        let maxCounter = 1;

        for (let key in obj) {
            if (+(obj[+key]) + 1 === +(obj[+key + 1])) {
                counter++;
            } else {
                if (counter > maxCounter) {
                    maxCounter = counter;
                }
                counter = 1;
            }
        }
        return maxCounter;
    }



</script>
</html>