<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
We can solve this problem in O(n) time using an Efficient Solution.


Мы можем решить эту проблему в O (n) раз, используя эффективное решение.
Идея заключается в использовании Хейшинга.
Сначала мы вставляем все элементы в хэш.
Затем проверьте все возможные последовательности последовательных подпоследовательностей.
Ниже приведен полный алгоритм.
1) Создайте пустой хэш.
2) Вставьте все элементы массива в хэш.
3) Следуйте для каждого элемента arr [i]
.... a) Проверьте, является ли этот элемент отправной точкой
       подпоследовательности. Чтобы проверить это, мы просто ищем
       arr [i] - 1 в hash, если не найден, то это
       первый элемент - подпоследовательность.
    
       Если этот элемент является первым элементом, то подсчет
       количество элементов в последовательном запуске
       с этим элементом.

       Если счетчик больше текущих, то обновите
       Рез.



</body>

<script>
    let arr1 = [100, 4, 200, 1, 3, 2, 101, 102, 103, 104];



    function longestConsecutiveLength(array) {
        if (array.length <= 1) return array.length;

        const sortedArr = array.sort((a, b) => a - b);
        let count = 1;

        const reducer = (acc, curr, i, arr) => {
            const diff = curr - arr[i - 1];

            if (diff === 1) count++;
            else if (diff > 1) {
                acc = count > acc
                    ? count
                    : acc;
                count = 1;
            }

            return acc;

        };

        const resultArr = sortedArr.reduce(reducer, 0);

        return resultArr;
    }








</script>
</html>